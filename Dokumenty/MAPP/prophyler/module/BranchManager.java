package prophyler.module;/* Branch Manager Classr   The following implements a method for assigning weights to the leaves of   an unrooted tree.  The procedure essentially calculates a weighted average   of "best weights" obtained by rooting the tree at the midpoint of each   branch.  For each fixed root position, these "best weights" are be   calculated in linear time (Felsenstein 1973), (Altschul, et al  1989).  If   n is the number of taxa, the program runs in O(n^2) time.   A description of the model, an explanation of "best weights", and the   validity and optimality of the implemented procedure are to follow. * <p>Copyright: Copyright (c) 2005  Eric Stone and Arend Sidow, Stanford University </p> * * <p>University: Stanford University</p>   Idea created by Eric Alan Stone   Coded by David Yau   v1.0  created 8/2002   v1.01 10/9/2002*/import java.io.*;import java.util.*;public class BranchManager {    private class node {	node left, right, parent;	double dist;	int[] children;	double cdist;       // int index;    }    private double[] weights;    private int numleaves;    private node root;    private double totaldist;    /* This is the constructor, it takes in a rooted tree described by an    array of ints giving the parent node for each node, and an array of    distances.  The root is always connected to node 0, and the leaves of    the tree always come first in the node*/    public BranchManager(int[] parentnode, double[] distances) {	if(parentnode.length!=distances.length) {	    //throw(new Exception("Data does not match"));	}	numleaves = parentnode.length/2;	System.out.println(parentnode);	/*  Building the Tree, first we create a node for each of the	nodes, since we are not gauranteed of their order in the array,	we keep a reference to them by an array, then we connect them up*/	node[] nodelist = new node[parentnode.length];	node tnode;	totaldist=0;	for(int i=0; i<parentnode.length; i++) {	    tnode = new node();	    tnode.left = null;	    tnode.right = null;	    tnode.parent = null;	    tnode.children = new int[numleaves+1];	    nodelist[i]=tnode;            //  tnode.index = i;	    if(i<=numleaves) {		tnode.children[0] = 1;		tnode.children[1] = i; //for the rooted tree algorithm	    }	}	/* connecting the tree*/	for(int i=0; i<parentnode.length; i++) {	    if(parentnode[i]!=-1) {		if(parentnode[i]==0) {		    root = nodelist[i];		}		nodelist[i].dist = distances[i]+0.000000000000000001;  //fudge factor, hopefully will be removed at later date		totaldist+=distances[i]+0.000000000000000001;		nodelist[i].parent = nodelist[parentnode[i]];		if(nodelist[i].parent.left==null) {		    nodelist[i].parent.left=nodelist[i];		}		else {		    nodelist[i].parent.right=nodelist[i];		}	    }	}	weights = new double[numleaves+1];	/* we first reroot the tree in the center of the branch it is	   currently in*/	root.left.dist = (root.left.dist+root.right.dist)/2;	root.right.dist = root.left.dist;    }    public double[] calculateWeights() {	rootedWeight(root.left.dist*2); //calculate the weight where it	                                //start off        if(root.left.left!=null) {            rerootLeft(root.left);        //these 4 traverse the rest of the tree            rerootRight(root.left);        }        if(root.right.left!=null) {            rerootLeft(root.right);            rerootRight(root.right);        }	// to normalize	for(int i=1; i<weights.length; i++) {	    weights[i]/=totaldist;	}	return weights;    }    private void rootedWeight(double d) {	double[] tweights = new double[numleaves+1];        //if(d!=0) {            collapse(root, tweights); //recursive function that implements	                          //feinstein algorithm            //	System.out.println("factor: " + d);            //printTreeDist();            for(int i=1; i<numleaves+1; i++) {                weights[i]+=d*tweights[i];                //   System.out.println(i + ":" + tweights[i]);            }    //    }    }    /* reroot left and reroot right are for moving the root for traversing    the tree and applying the algorithm to all the branches.  Reroot left    takes in a node who's parent is the current Root.  It then moves the    root to the node's left branch, then recurses down to the node's new    left child.  It calls the rooted weight algorithm.  At the exit of the    function, it returns the tree to its previous state so that it can    traverse in the other direction*/    private void rerootLeft(node n) {	if(n.parent!=root) {	    System.out.println("error in BranchManger");	}	//	if(n.left!=null) {	boolean wasleft;	node tnode = n.left;	//remember the original state of the tree	if(root.left==n) {	    wasleft=true;	    n.left = root.right;	}	else {	    wasleft=false;	    n.left = root.left;	}	//change connectivity, set distances	n.left.parent = n;	n.left.dist*=2;	root.right = n;	root.left = tnode;	tnode.dist/=2;	n.dist = tnode.dist;	tnode.parent = root;	//calculate weight of modified tree and recurse	rootedWeight(root.left.dist*2);	if(root.left.left!=null) {	    rerootLeft(root.left);	}	if(root.left.left!=null) {	    rerootRight(root.left);	}	//set tree back to original state	tnode.dist*=2;	n.left.dist/=2;	n.left.parent = root;	n.dist=n.left.dist;	if(wasleft) {	    root.left = n;	    root.right = n.left;	}	else {	    root.right = n;	    root.left = n.left;	}	n.left=tnode;	tnode.parent = n;    }    /* same as recurse left, symmetric*/    private void rerootRight(node n) {	//System.out.println("Doing " + n.index + "'s right");        if(n.parent!=root) {            System.out.println("error in BranchManager");        }	//if(n.right!=null) {	boolean wasright;	node tnode = n.right;	if(root.right==n) {	    wasright=true;	    n.right = root.left;	}	else {	    wasright=false;	    n.right = root.right;	}	n.right.parent = n;	n.right.dist*=2;	root.left = n;	root.right = tnode;	tnode.dist/=2;	n.dist = tnode.dist;	tnode.parent=root;	rootedWeight(root.right.dist*2);	if(root.right.right!=null) {	    rerootLeft(root.right);	}	if(root.right.right!=null) {	    rerootRight(root.right);	}	tnode.dist*=2;	n.right.dist/=2;	n.right.parent=root;	n.dist=n.right.dist;	if(wasright) {	    root.right = n;	    root.left = n.right;	}	else {	    root.left = n;	    root.right = n.right;	}	n.right=tnode;	tnode.parent = n;    }    //these 2 for debugging purposes    private void printTreeDist() {	printNode(root);    }    private void printNode(node n) {	if(n.left!=null) {	    printNode(n.left);	    printNode(n.right);	}	System.out.println(n.dist);    }    /* Implements felsenstein's algorithm for weighting a rooted tree.       Basically goes to the bottom of the tree, then collapses pairs of       children and turns them into one equivalent node, then repeates as       it works it's way up until there's only 1 node left.  The vector       describing the last node is the weights*/    private void collapse(node n, double[] tweights) {	//if at a leaf	double trdist,tldist;        if(n.left==null) {	    n.cdist = n.dist;	}	else {	    //recurse	    collapse(n.left, tweights);	    collapse(n.right, tweights);	    /*find out who it's children leaves are, need to know this so	    when it builds up, the parent can find out who it's children	    are to multiply by*/	    n.children[0] = n.left.children[0]+n.right.children[0];	    for(int i=0; i<n.left.children[0]; i++) {		n.children[1+i] = n.left.children[1+i];	    }	    for(int i=0; i<n.right.children[0]; i++) {		n.children[1+i+n.left.children[0]] =		    n.right.children[1+i];	    }	    // new node's equivalent distance            if(n.left.cdist!=0||n.right.cdist!=0) {                n.cdist =                    ((n.left.cdist*n.right.cdist)/(n.left.cdist+n.right.cdist))+n.dist;                tldist = n.right.cdist/(n.left.cdist+n.right.cdist);                trdist = n.left.cdist/(n.left.cdist+n.right.cdist);            }            else {                n.cdist = 0;                tldist = 0;                trdist = 0;            }	    // multiplies wieghts vectors of it's 2 children by the	    //correct amount	    for(int i=0; i<n.left.children[0]; i++) {		if(tweights[n.left.children[i+1]]==0) {		    tweights[n.left.children[i+1]] = tldist;		}		else {		    tweights[n.left.children[i+1]]*=tldist;		}	    }	    for(int i=0; i<n.right.children[0]; i++) {		if(tweights[n.right.children[i+1]]==0) {		    tweights[n.right.children[i+1]] = trdist;		}		else {		    tweights[n.right.children[i+1]]*=trdist;		}	    }	}    }}